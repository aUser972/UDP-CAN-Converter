# Тестирование проекта

Для тестирования проекта реализуем подключение по следующей схеме.
![Scheme](./Scheme.png "Схема подключения")

Здесь входящие порты 5000, 5001, 5002, 5003 связываются с устройствами dev1, dev2, dev3,dev4 соответственно на интерфейсах vcan0 и vcan1.
Код для связывания UDP портов и устройств на CAN шине:
```
int first = ConverterUDP2CAN(0x1, "vcan0", 5, 1024, 5000);
int second = ConverterUDP2CAN(0x2, "vcan0", 5, 1024, 5001);
int third = ConverterUDP2CAN(0x3, "vcan1", 5, 1024, 5002);
int fourth = ConverterUDP2CAN(0x4, "vcan1", 5, 1024, 5003);
```
Код для связывания CAN интерфейсов и исходящего UDP порта:
```
int fifth = ConverterCAN2UDP("127.0.0.1", 9, 5004, "vcan0", 5);
int sixth = ConverterCAN2UDP("127.0.0.1", 9, 5004, "vcan1", 5);
```
Исходный код используемый для тестирования проекта смотрите в директории `/Example`.

## Проверка соединения UDP-CAN
Для проверки соединения необходимо отправлять в UDP порты 5000, 5001, 5002, 5003 localhost'a пакеты. Для этого воспользуемся командой:
```
echo "ABCD" > /dev/udp/localhost/5000
echo "EFGH" > /dev/udp/localhost/5001
echo "IJKL" > /dev/udp/localhost/5002
echo "MNOP" > /dev/udp/localhost/5003
```
Для просмотра данных пришедших на CAN шину vcan0 и vcan1 воспользуемся командами:
```
cansniffer vcan0
cansniffer vcan1
```

## Проверка соединения CAN-UDP
Для проверки соединения необходимо прослушать UDP сокет localhost:5004. Для этого воспользуемся утилитой netcat:
```
nc -l -u 5004
```
Далее необходимо имитировать данные отправляемые устройством на CAN шине. В сообщении закодируем имя CAN интерфейса, через который отправляются данные. В таблице ascii строке "vcan0" соответствует 564341E30 hex значение. Для строки "vcan1" hex значение равно 564341E31. Для имитации данных, отправляемых устройством на CAN шине воспользуемся утилитой cangen:

```
cangen vcan0 -g 2000 -I 42A -D 5643414E30202020 -L 8
cangen vcan1 -g 2000 -I 42B -D 5643414E31202020 -L 8
```
### NOTE:
По какой-то причине утилита netcat не выводит все данные, пришедшие в порт. Простой UDP сервер, написанный на языке C, который читает пришедшие в порт данные, оказывается более предсказуемым и показывает результаты отличные от утилиты netcat. Возможно, netcat действительно не лучшая тулза для чтения пакетов. В итоге самописный UDP сервер выдает ожидаемые данные, которые соответствуют требованиям.  
